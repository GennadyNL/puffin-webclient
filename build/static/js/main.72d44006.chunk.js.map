{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","handleSelectedFile","e","updateContent","setState","selectedFile","target","files","loaded","size","formattedSize","returnFormattedFileSize","updateFileDetails","name","reader","FileReader","onloadend","a","text","result","readAsBinaryString","readSelectedFile","handleUpload","loading","data","window","FormData","file","document","getElementById","append","value","axios","post","headers","then","response","console","log","status","statusText","catch","error","toString","request","readyState","responseText","message","fileContent","fileDetails","filesize","i","Math","round","state","imageUrl","bind","className","Progress","animated","color","this","src","vspace","valign","width","height","alt","type","id","onChange","Button","onClick","Component","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.72d44006.chunk.js","sourcesContent":["import axios from 'axios';\nimport React, { Component } from 'react';\n//import logo from './logo.svg';\nimport './App.css';\nimport { Button } from 'reactstrap';\nimport { Progress } from 'reactstrap';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      loaded:0,\n      selectedFile:'',\n      imageUrl:''\n    }\n    this.handleSelectedFile = this.handleSelectedFile.bind(this);\n    this.handleUpload = this.handleUpload.bind(this)\n  }\n\n  handleSelectedFile = e => {\n    this.updateContent(\"Loading file content...\")\n    this.setState({\n      selectedFile: e.target.files[0],\n      loaded: 0,\n    })\n    if (e.target.files[0].size >= 1024)\n    {\n      let formattedSize = this.returnFormattedFileSize(e.target.files[0].size)\n      this.updateFileDetails(\"Filename: \" + e.target.files[0].name + \"\\nFilesize : \" + formattedSize + \" (\" + e.target.files[0].size + \" bytes)\")\n    }\n    else\n    {\n      this.updateFileDetails(\"Filename: \" + e.target.files[0].name + \"\\nFilesize : \" + e.target.files[0].size + \" bytes\")\n    }\n\n    // This code can read the selected file and show its content in browser; works slow with large (20+ Mb) files\n    const readSelectedFile = e => {\n      const reader = new FileReader()\n      reader.onloadend = async (e) => { \n        const text = (e.target.result)\n        this.updateContent(text)\n      };\n      reader.readAsBinaryString(e.target.files[0])\n    }\n    readSelectedFile(e)\n  }\n\n  handleUpload = () => {\n    this.setState({ loading: true })\n    this.updateContent(\"Uploading file to Puffin...\")\n    \n    let target = \"http://webhook.site/d01f78b4-48f8-4196-9dad-e9502622cf0d\"\n    //let target = \"http://localhost:8080/\"  // Puffin instance should run there\n    let data = new window.FormData()\n    let file = document.getElementById('userFile')\n\n    data.append(file,file.value)\n\n    axios.post(target,\n               data,\n               { headers:\n                  { \n                    'Content-Type': 'application/json;charset=UTF-8',\n                    //\"Access-Control-Allow-Origin\": \"*\",\n                  }\n               })\n    .then(response => {\n      console.log(\"Response status: \" + response.status)\n      console.log(\"Response status text: \" + response.statusText)\n      console.log(\"Response data: \" + response.data)\n      console.log(\"Response headers: \" + response.headers)\n      this.updateContent(\"Target Puffin URL: \" + target + \"\\n\\nResponse status: \" + response.status + \" \" + response.statusText)\n    })\n    .catch(error => {\n        this.updateContent(\"Target Puffin URL: \" + target + \"\\n\\n\" + error.toString())\n        if (error.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.log(\"Error response data: \" + error.response.data)\n        console.log(\"Error response status: \" + error.response.status)\n        console.log(\"Error request: \" + error.response.headers)\n      } else if (error.request) {\n        // The request was made but no response was received\n        // `error.request` is an instance of XMLHttpRequest in the browser\n        console.log(\"Error request: \" + error.request)\n        console.log(\"Error request readyState: \" + error.request.readyState)\n        console.log(\"Error request response Text: \" + error.request.responseText)\n        console.log(\"Error request status: \" + error.request.status)\n        console.log(\"Error request status text: \" + error.request.statusText)\n      } else {\n        // Something happened in setting up the request that triggered an Error\n        console.log(\"Error: \" + error.message);\n      }\n    })\n\n/*     axios\n      .post(\n        target,\n        data,\n        { headers:\n          { \n            'Content-Type': 'application/json',\n            'Access-Control-Allow-Origin' : '*'\n          }\n        }\n      ) */\n/*         .then(res => {\n          if (res.data.messages) {\n            this.setState({\n              loading: false,\n              csvError: true,\n              csvErrorMessages: res.data.messages,\n              resStatus: res.status\n            })\n          } else {\n            this.setState({\n              loading: false,\n              success: true,\n              summaries: res.data.summary.totals,\n              hash: res.data.summary.hash,\n              resStatus: res.status\n            })\n          }\n        })\n        .catch(() => {\n          this.setState({\n            loading: false,\n            requestError: true,\n            requestErrorMessage: { text: 'Unable to connect to the server' }\n          })\n        }) */\n    }\n\n  updateContent = fileContent => {\n    this.setState({ message: fileContent});\n  }\n\n  updateFileDetails = fileDetails => {\n    this.setState({ fileDetails: fileDetails});\n  }\n\n  returnFormattedFileSize = filesize => {\n      var fileSizeExtension = ['Bytes', 'KB', 'MB', 'GB']\n      let i = 0\n      while (filesize > 900)\n      {\n        filesize/=1024\n        i++\n      }\n      var exactSize = (Math.round(filesize*100)/100)+' '+fileSizeExtension[i];\n      return exactSize;\n  }\n\n  render() {\n  return (\n    <div className=\"App\">\n      <div className=\"App-header\">\n        <Progress animated color=\"info\" value={Math.round(this.state.loaded,2) } />\n          <img src=\"puffin_image.jpg\" vspace=\"10\" valign=\"top\" width=\"600\" height=\"216\" alt=\"Here is one puffin\"></img>\n          <div className=\"div-table\">Select your file for validation and press Upload button</div>\n          <div className=\"div-table\">\n              <div className=\"div-table-col\">\n                  <label>\n                    <input className=\"UploadButtonHide\" type=\"file\" name=\"userFile\" id=\"userFile\" onChange={e => this.handleSelectedFile(e)}/>\n                    <span className=\"Button\">Select file</span>\n                  </label>\n              </div>\n              <div className=\"div-table-col FileDetails\">{this.state.fileDetails}</div>\n              <div className=\"div-table-col div-table-col-right\">\n                <Button className=\"Button\" onClick={e => this.handleUpload()}>Upload</Button>\n              </div>\n        </div>\n\n        <div className = \"FileContent\">{this.state.message}</div>\n      </div>\n    </div>\n  )\n  }\n}\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}